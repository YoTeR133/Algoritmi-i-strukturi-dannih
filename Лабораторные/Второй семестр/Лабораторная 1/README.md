# Лабораторная работа №1: Сортировка Шелла

## Описание
В рамках лабораторной работы реализован алгоритм сортировки Шелла в классах `UnorderedArray` и `OrderedArray`. Проведен анализ влияния выбора интервальной последовательности на скорость выполнения алгоритма.

## Реализация
- Метод `shell_sort(sequence_type)` добавлен в оба класса.
- Поддерживаемые последовательности:
  1. **Knuth**: `h = h * 3 + 1`, уменьшение `h = (h - 1) // 3`.
  2. **Shell**: `h = N // 2`, уменьшение `h = h // 2`.
  3. **ImprovedShell**: `h = N / 2.2`, уменьшение `h = h / 2.2`.
- Тестирование выполнено в `client.py`. Для повышения точности измерений использован `time.perf_counter()` с усреднением по 1000 запускам. Без этого метода (с использованием `time.time()`) скорость часто показывалась как 0.000 мс из-за ограничений разрешения таймера, особенно на небольших массивах.

## Результаты
Тестирование проводилось на массивах случайных чисел от 1 до 100. Время указано в миллисекундах (усредненное по 1000 запускам).

| Класс            | Последовательность | Формула             | Размер массива | Время (мс) |
|-------------------|--------------------|---------------------|----------------|------------|
| UnorderedArray   | Knuth             | h = 3h + 1         | 100            | 0.115      |
| UnorderedArray   | Shell             | h = N // 2         | 100            | 0.127      |
| UnorderedArray   | ImprovedShell     | h = N / 2.2        | 100            | 0.113      |
| UnorderedArray   | Knuth             | h = 3h + 1         | 500            | 0.858      |
| UnorderedArray   | Shell             | h = N // 2         | 500            | 0.899      |
| UnorderedArray   | ImprovedShell     | h = N / 2.2        | 500            | 0.813      |
| UnorderedArray   | Knuth             | h = 3h + 1         | 1000           | 2.009      |
| UnorderedArray   | Shell             | h = N // 2         | 1000           | 2.138      |
| UnorderedArray   | ImprovedShell     | h = N / 2.2        | 1000           | 1.850      |
| OrderedArray     | Knuth             | h = 3h + 1         | 100            | 0.042      |
| OrderedArray     | Shell             | h = N // 2         | 100            | 0.056      |
| OrderedArray     | ImprovedShell     | h = N / 2.2        | 100            | 0.047      |
| OrderedArray     | Knuth             | h = 3h + 1         | 500            | 0.314      |
| OrderedArray     | Shell             | h = N // 2         | 500            | 0.435      |
| OrderedArray     | ImprovedShell     | h = N / 2.2        | 500            | 0.382      |
| OrderedArray     | Knuth             | h = 3h + 1         | 1000           | 0.721      |
| OrderedArray     | Shell             | h = N // 2         | 1000           | 1.052      |
| OrderedArray     | ImprovedShell     | h = N / 2.2        | 1000           | 0.940      |

## Вывод
1. **ImprovedShell** демонстрирует наилучшую производительность для `UnorderedArray` на всех размерах (0.113 мс для 100, 0.813 мс для 500, 1.850 мс для 1000), что объясняется более плавным уменьшением интервалов по сравнению с Shell.
2. **Shell** стабильно оказывается самой медленной последовательностью (0.127 мс для 100, 0.899 мс для 500, 2.138 мс для 1000 в `UnorderedArray`; 0.056 мс для 100, 0.435 мс для 500, 1.052 мс для 1000 в `OrderedArray`), что подтверждает ее меньшую эффективность на случайных данных.
3. **Knuth** занимает промежуточное положение (0.115 мс для 100, 0.858 мс для 500, 2.009 мс для 1000 в `UnorderedArray`), но в `OrderedArray` часто работает быстрее Shell (0.042 мс для 100, 0.314 мс для 500, 0.721 мс для 1000), вероятно, из-за частичной упорядоченности данных.
4. Использование `time.perf_counter()` позволило получить точные ненулевые значения даже для небольших массивов (например, 100 элементов), в отличие от `time.time()`, где скорость часто показывалась как 0.000 мс из-за ограничений разрешения таймера.
5. `OrderedArray` работает заметно быстрее `UnorderedArray` (например, 0.721 мс против 2.009 мс для Knuth при 1000), так как данные при вставке уже частично отсортированы, что снижает количество операций в сортировке Шелла.